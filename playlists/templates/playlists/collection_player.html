{% extends "base.html" %}
{% load static %}

{% block title %}{{ collection.name }} - Relaxify{% endblock %}

{% block extra_css %}
    <link href="{% static 'css/collection_player.css' %}" rel="stylesheet">
{% endblock %}

{% block extra_js %}
    <script src="{% static 'js/offline-storage.js' %}"></script>
{% endblock %}

{% block content %}
    <div class="player-container">
        <!-- Video Section -->
        <div class="video-section">
            <!-- Close Button -->
            <button class="close-btn" onclick="location.href='{% url 'playlists:home' %}'">
                <i class="fas fa-times"></i>
            </button>

            <!-- Video Player -->
            <div class="video-player" id="video-container">
                <div class="loading-placeholder" id="loading-placeholder">
                    <div class="spinner"></div>
                    <p>Waiting for player...</p>
                </div>
                <div id="youtube-player"></div>
                
                <!-- Video Loading Indicator -->
                <div class="video-loading-indicator" id="video-loading-indicator">
                    <div class="video-loading-spinner"></div>
                    <span class="video-loading-text">Loading video...</span>
                </div>
            </div>

            <!-- Video Info -->
            <div class="video-info">
                <h1 class="video-title" id="current-title">Select a track to start playing</h1>
                <div class="video-artist" id="current-artist">Choose from the playlist on the right</div>
                <div class="video-stats">
                    <span><i class="fas fa-clock"></i> <span id="current-duration">--:--</span></span>
                    <span><i class="fas fa-eye"></i> <span id="current-views">--</span> views</span>
                </div>
            </div>
        </div>

        <!-- Playlist Section -->
        <div class="playlist-section">
            <!-- Playlist Header -->
            <div class="row playlist-header d-flex justify-content-between">
                <div class="col-12 playlist-title">
                    {{ collection.name }}
                </div>
                <div class="col-12 playlist-subtitle d-flex justify-content-start">
                    {% if collection.platform == 'youtube' or collection.platform == 'youtube_music' %}
                        <span class="platform-badge">
                            <i class="fab fa-youtube"></i> YouTube
                        </span>
                    {% endif %}
                    <span id="track-count">{{ collection.playlist_count }} tracks</span>
                    <span id="cached-indicator" class="cached-indicator" style="display: none;">
                        <i class="fas fa-download"></i> Cached
                    </span>
                    <button class="control-btn" onclick="saveForOffline()" title="Save for Offline" id="saveOfflineBtn">
                        <i class="fas fa-download"></i>
                    </button>
                    <button class="control-btn" onclick="shufflePlaylist()" title="Shuffle">
                        <i class="fas fa-random"></i>
                    </button>
                    <button class="control-btn" onclick="toggleLoop()" title="Loop" id="loopBtn">
                        <i class="fas fa-redo"></i>
                    </button>
                    <button class="control-btn" onclick="toggleAutoplay()" title="Autoplay" id="autoplayBtn">
                        <i class="fas fa-play-circle"></i>
                    </button>
                </div>
            </div>

            <!-- Track List -->
            <div class="track-list">
                {% if tracks %}
                    {% for track in tracks %}
                        <div class="track-item" 
                             data-track-id="{{ track.id }}"
                             data-youtube-id="{{ track.youtube_id }}"
                             data-title="{{ track.title|escapejs }}"
                             data-artist="{{ track.artist|default:'Unknown Artist'|escapejs }}"
                             data-duration="{{ track.duration|default:'--:--' }}"
                             data-views="{{ track.view_count|default:0 }}"
                             data-thumbnail="{{ track.thumbnail_url|default:'' }}"
                             onclick="playTrack({{ forloop.counter0 }})">
                            
                            <div class="track-number" id="track-number-{{ forloop.counter0 }}">
                                {{ forloop.counter }}
                            </div>
                            
                            {% if track.thumbnail_url %}
                                <img src="{{ track.thumbnail_url }}" alt="{{ track.title }}" class="track-thumbnail">
                            {% else %}
                                <div class="track-thumbnail-placeholder">
                                    <i class="fas fa-music" style="font-size: 0.7rem; color: rgba(255,255,255,0.5);"></i>
                                </div>
                            {% endif %}
                            
                            <div class="track-info">
                                <div class="track-title">{{ track.title }}</div>
                                <div class="track-artist">{{ track.artist|default:"Unknown Artist" }}</div>
                            </div>
                            
                            <div class="track-duration">{{ track.duration|default:"--:--" }}</div>
                            
                            <div class="track-actions" style="opacity: 0; transition: opacity 0.2s; display: flex; align-items: center;">
                                <button class="track-action-btn" onclick="event.stopPropagation(); removeTrack({{ track.id }}, {{ forloop.counter0 }})" title="Remove track">
                                    <i class="fas fa-minus" style="color: #ff4444;"></i>
                                </button>
                            </div>
                        </div>
                    {% endfor %}
                {% else %}
                    <div style="text-align: center; padding: 2rem; color: #aaa;">
                        <i class="fas fa-music" style="font-size: 2rem; margin-bottom: 1rem; opacity: 0.5;"></i>
                        <p>No tracks in this collection</p>
                    </div>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Track Loading Overlay -->
    <div class="track-loading-overlay" id="track-loading-overlay">
        <div class="track-loading-content">
            <div class="track-loading-spinner"></div>
            <div class="track-loading-text" id="track-loading-text">Loading track...</div>
            <div class="track-loading-subtitle" id="track-loading-subtitle">Preparing video player</div>
            <div class="track-loading-progress">
                <div class="track-loading-progress-bar"></div>
            </div>
        </div>
    </div>

    <script>
        let player;
        let currentTrackIndex = -1;
        let isPlaying = false;
        let isLoop = false;
        let isAutoplay = true;
        let tracks = [];
        let offlineStorage;
        let isOffline = !navigator.onLine;
        let currentIframe = null; // For iPhone iframe management
        let isFirstVideo = true; // Track if this is the first video
        let collectionData = {
            id: {{ collection.id }},
            name: '{{ collection.name|escapejs }}',
            platform: '{{ collection.platform }}',
            playlist_count: {{ collection.playlist_count }}
        };

        // Initialize tracks data
        {% if tracks %}
        tracks = [
            {% for track in tracks %}
            {
                id: {{ track.id }},
                youtube_id: '{{ track.youtube_id }}',
                title: '{{ track.title|escapejs }}',
                artist: '{{ track.artist|default:"Unknown Artist"|escapejs }}',
                duration: '{{ track.duration|default:"--:--" }}',
                views: {{ track.view_count|default:0 }},
                thumbnail: '{{ track.thumbnail_url|default:"" }}'
            }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ];
        {% endif %}

        function playTrack(index) {
            if (currentTrackIndex === index && player && isPlaying) {
                // If same track is playing, just pause/play
                player.pauseVideo();
                return;
            }

            currentTrackIndex = index;
            const track = tracks[index];
            
            // Show loading animation
            showTrackLoadingAnimation(track);
            
            // Update video info
            updateVideoInfo(track);
            
            // Update track list UI
            updateTrackListUI(index);
            
            // Save player state
            savePlayerState();
            
            // Load YouTube player (only if online or if we have cached video data)
            if (isOffline) {
                // In offline mode, show track info without video
                document.getElementById('current-title').textContent = track.title;
                document.getElementById('current-artist').textContent = track.artist;
                showNotification('ðŸ“± Offline Mode: Track info available, video requires internet', 'info');
                hideTrackLoadingAnimation();
            } else {
                // Online mode - load YouTube player
                if (player) {
                    showVideoLoadingIndicator();
                    player.loadVideoById(track.youtube_id);
                    // Auto-play the video after loading
                    setTimeout(() => {
                        if (player && player.playVideo) {
                            player.playVideo();
                        }
                        hideVideoLoadingIndicator();
                        hideTrackLoadingAnimation();
                    }, 1000); // Small delay to ensure video is loaded
                    hideLoadingPlaceholder();
                } else {
                    initYouTubePlayer(track.youtube_id);
                }
            }
            
            isPlaying = true;
        }

        function updateVideoInfo(track) {
            document.getElementById('current-title').textContent = track.title;
            document.getElementById('current-artist').textContent = track.artist;
            document.getElementById('current-duration').textContent = track.duration;
            document.getElementById('current-views').textContent = track.views.toLocaleString();
        }

        function updateTrackListUI(playingIndex) {
            // Remove all playing states
            document.querySelectorAll('.track-item').forEach((item, index) => {
                item.classList.remove('playing');
                const numberEl = document.getElementById(`track-number-${index}`);
                if (numberEl) {
                    numberEl.textContent = index + 1;
                    numberEl.classList.remove('playing');
                }
            });
            
            // Add playing state to current track
            const currentItem = document.querySelector(`[data-track-id="${tracks[playingIndex].id}"]`);
            if (currentItem) {
                currentItem.classList.add('playing');
                const numberEl = document.getElementById(`track-number-${playingIndex}`);
                if (numberEl) {
                    numberEl.innerHTML = '<i class="fas fa-volume-up"></i>';
                    numberEl.classList.add('playing');
                }
                
                // Scroll into view
                currentItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function initYouTubePlayer(videoId) {
            if (!window.YT) {
                const script = document.createElement('script');
                script.src = 'https://www.youtube.com/iframe_api';
                document.head.appendChild(script);
                
                window.onYouTubeIframeAPIReady = function() {
                    createPlayer(videoId);
                };
            } else {
                createPlayer(videoId);
            }
        }

        function createPlayer(videoId) {
            // Detect iPhone to use iframe instead of YouTube API
            const isIPhone = /iPhone|iPad|iPod/.test(navigator.userAgent);
            
            if (isIPhone) {
                // Use direct iframe for iPhone (works better)
                createIPhoneIframePlayer(videoId);
            } else {
                // Use YouTube API for other devices
                player = new YT.Player('youtube-player', {
                    height: '100%',
                    width: '100%',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1,
                        'rel': 0,
                        'modestbranding': 1,
                        'controls': 1,
                        'showinfo': 0,
                        'autoplay': 1
                    },
                    events: {
                        'onReady': onPlayerReady,
                        'onStateChange': onPlayerStateChange
                    }
                });
                
                hideLoadingPlaceholder();
            }
        }

        function createIPhoneIframePlayer(videoId) {
            const videoContainer = document.getElementById('video-container');
            
            // Clear existing content
            videoContainer.innerHTML = '';
            
            // Create iframe with iPhone-optimized parameters (based on your working example)
            currentIframe = document.createElement('iframe');
            currentIframe.id = 'youtube-player';
            currentIframe.width = '100%';
            currentIframe.height = '100%';
            currentIframe.frameBorder = '0';
            currentIframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
            currentIframe.allowFullscreen = true;
            currentIframe.referrerPolicy = 'strict-origin-when-cross-origin';
            
            // Use mute=1 only for the first video, then unmute for subsequent videos
            const muteParam = isFirstVideo ? '&mute=1' : '';
            currentIframe.src = `https://www.youtube.com/embed/${videoId}?playsinline=1${muteParam}&autoplay=1&rel=0&modestbranding=1&controls=1&showinfo=0&enablejsapi=1&start=0`;
            
            // Mark that we've played the first video
            isFirstVideo = false;
            
            currentIframe.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                border: none;
            `;
            
            videoContainer.appendChild(currentIframe);
            
            // Create a mock player object for iPhone compatibility
            player = {
                playVideo: function() {
                    console.log('iPhone: Video should already be playing with autoplay');
                    // Try to trigger play by refreshing the iframe with autoplay
                    if (currentIframe) {
                        const currentSrc = currentIframe.src;
                        if (!currentSrc.includes('autoplay=1')) {
                            currentIframe.src = currentSrc + (currentSrc.includes('?') ? '&' : '?') + 'autoplay=1';
                        }
                    }
                },
                pauseVideo: function() {
                    console.log('iPhone: Pause not available in iframe mode');
                },
                stopVideo: function() {
                    console.log('iPhone: Stop not available in iframe mode');
                },
                getPlayerState: function() {
                    return 1; // PLAYING state
                },
                loadVideoById: function(id) {
                    console.log('iPhone: Loading new video:', id);
                    // Completely recreate the iframe for new video
                    createIPhoneIframePlayer(id);
                },
                destroy: function() {
                    if (currentIframe && currentIframe.parentNode) {
                        currentIframe.parentNode.removeChild(currentIframe);
                    }
                }
            };
            
            hideLoadingPlaceholder();
            hideVideoLoadingIndicator();
            hideTrackLoadingAnimation();
            console.log('iPhone iframe player created successfully');
        }

        function hideLoadingPlaceholder() {
            document.getElementById('loading-placeholder').style.display = 'none';
        }

        // Loading Animation Functions
        function showTrackLoadingAnimation(track) {
            const overlay = document.getElementById('track-loading-overlay');
            const text = document.getElementById('track-loading-text');
            const subtitle = document.getElementById('track-loading-subtitle');
            
            text.textContent = `Loading "${track.title}"`;
            subtitle.textContent = `by ${track.artist}`;
            
            overlay.classList.add('show');
        }

        function hideTrackLoadingAnimation() {
            const overlay = document.getElementById('track-loading-overlay');
            overlay.classList.remove('show');
        }

        function showVideoLoadingIndicator() {
            const indicator = document.getElementById('video-loading-indicator');
            indicator.classList.add('show');
        }

        function hideVideoLoadingIndicator() {
            const indicator = document.getElementById('video-loading-indicator');
            indicator.classList.remove('show');
        }


        function onPlayerReady(event) {
            // Player is ready
            console.log('YouTube player ready');
            // Auto-play the video when ready
            if (player && player.playVideo) {
                player.playVideo();
            }
            // Hide loading animations
            hideVideoLoadingIndicator();
            hideTrackLoadingAnimation();
        }

        function onPlayerStateChange(event) {
            if (event.data == YT.PlayerState.ENDED) {
                if (isLoop) {
                    player.seekTo(0);
                    player.playVideo();
                } else if (isAutoplay) {
                    playNext();
                }
            } else if (event.data == YT.PlayerState.PLAYING) {
                isPlaying = true;
            } else if (event.data == YT.PlayerState.PAUSED) {
                isPlaying = false;
            }
        }

        function playNext() {
            if (currentTrackIndex < tracks.length - 1) {
                const nextTrack = tracks[currentTrackIndex + 1];
                
                // Show auto-advance notification
                if (isAutoplay) {
                    showAutoAdvanceNotification(nextTrack);
                }
                
                playTrack(currentTrackIndex + 1);
            } else if (isLoop) {
                const firstTrack = tracks[0];
                
                // Show loop notification
                showAutoAdvanceNotification(firstTrack, true);
                
                playTrack(0); // Start from beginning if loop is on
            }
        }

        function showAutoAdvanceNotification(track, isLoop = false) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 1rem;
                border-radius: 8px;
                z-index: 9999;
                font-size: 0.9rem;
                opacity: 0;
                transition: opacity 0.3s;
                max-width: 300px;
                border-left: 4px solid #1db954;
            `;
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                    <i class="fas fa-${isLoop ? 'redo' : 'forward'}"></i>
                    <strong>${isLoop ? 'Looping to' : 'Auto-playing'}</strong>
                </div>
                <div style="font-size: 0.8rem; color: #ccc;">
                    ${track.title}
                </div>
            `;
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => notification.style.opacity = '1', 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        function playPrevious() {
            if (currentTrackIndex > 0) {
                playTrack(currentTrackIndex - 1);
            }
        }

        function shufflePlaylist() {
            if (tracks.length > 0) {
                const randomIndex = Math.floor(Math.random() * tracks.length);
                playTrack(randomIndex);
            }
        }

        function toggleLoop() {
            isLoop = !isLoop;
            const loopBtn = document.getElementById('loopBtn');
            loopBtn.classList.toggle('active', isLoop);
            
            // Save state
            savePlayerState();
        }

        function toggleAutoplay() {
            isAutoplay = !isAutoplay;
            const autoplayBtn = document.getElementById('autoplayBtn');
            autoplayBtn.classList.toggle('active', isAutoplay);
            
            // Save state
            savePlayerState();
            
            // Show notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${isAutoplay ? '#1db954' : '#ff4444'};
                color: white;
                padding: 0.75rem 1rem;
                border-radius: 8px;
                z-index: 9999;
                font-size: 0.9rem;
                opacity: 0;
                transition: opacity 0.3s;
            `;
            notification.innerHTML = `
                <i class="fas fa-${isAutoplay ? 'check' : 'times'}"></i> 
                Autoplay ${isAutoplay ? 'ON' : 'OFF'}
            `;
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => notification.style.opacity = '1', 10);
            
            // Remove after 2 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => document.body.removeChild(notification), 300);
            }, 2000);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            switch(e.code) {
                case 'Space':
                    e.preventDefault();
                    if (player && currentTrackIndex >= 0) {
                        if (isPlaying) {
                            player.pauseVideo();
                        } else {
                            player.playVideo();
                        }
                    }
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    playNext();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    playPrevious();
                    break;
                case 'KeyS':
                    e.preventDefault();
                    shufflePlaylist();
                    break;
                case 'KeyL':
                    e.preventDefault();
                    toggleLoop();
                    break;
                case 'KeyA':
                    e.preventDefault();
                    toggleAutoplay();
                    break;
                case 'Escape':
                    e.preventDefault();
                    location.href = '{% url "playlists:home" %}';
                    break;
            }
        });

        // Initialize offline storage and UI
        document.addEventListener('DOMContentLoaded', async function() {
            // Set up online detection for automatic redirect
            setupOnlineDetection();
            // Check if we're in offline mode (data loaded from sessionStorage)
            const offlineMode = sessionStorage.getItem('offlineMode') === 'true';
            const offlineCollectionData = sessionStorage.getItem('offlineCollection');
            const offlineTracksData = sessionStorage.getItem('offlineTracks');
            
            if (offlineMode && offlineCollectionData && offlineTracksData) {
                // Load offline data from sessionStorage
                try {
                    collectionData = JSON.parse(offlineCollectionData);
                    tracks = JSON.parse(offlineTracksData);
                    
                    // Update UI for offline mode
                    document.getElementById('current-title').textContent = 'Offline Mode - Cached Playlist';
                    document.getElementById('current-artist').textContent = `${tracks.length} tracks available offline`;
                    
                    // Show offline indicators
                    showCachedIndicator();
                    updateOfflineStatus();
                    
                    // Clear sessionStorage data
                    sessionStorage.removeItem('offlineMode');
                    sessionStorage.removeItem('offlineCollection');
                    sessionStorage.removeItem('offlineTracks');
                    
                    console.log(`Loaded ${tracks.length} tracks from offline session storage`);
                } catch (error) {
                    console.error('Error loading offline data from sessionStorage:', error);
                }
            } else if (isOffline && !navigator.onLine) {
                // If we're offline and no session data, redirect to offline player
                console.log('Offline mode detected, redirecting to offline player...');
                window.location.href = `/static/offline-player.html?id=${collectionData.id}`;
                return;
            } else {
                // Normal online mode initialization
                if (OfflineStorageManager.isSupported()) {
                    offlineStorage = new OfflineStorageManager();
                    await offlineStorage.init();
                    
                    // Check if we're offline and load cached data
                    if (isOffline) {
                        await loadOfflineData();
                    } else {
                        // Check if collection is cached
                        const isCached = await offlineStorage.isCollectionCached(collectionData.id);
                        if (isCached) {
                            showCachedIndicator();
                        }
                    }
                    
                    // Load saved player state
                    await loadPlayerState();
                } else {
                    console.warn('Offline storage not supported in this browser');
                    document.getElementById('saveOfflineBtn').style.display = 'none';
                }
                
                // Update offline status
                updateOfflineStatus();
            }
            
            // Set autoplay button as active by default
            const autoplayBtn = document.getElementById('autoplayBtn');
            autoplayBtn.classList.add('active');
            autoplayBtn.title = 'Autoplay: ON';
            
            // Optional: Auto-start playing first track
            // playTrack(0);
        });

        // Load data from offline storage
        async function loadOfflineData() {
            try {
                const [cachedCollection, cachedTracks] = await Promise.all([
                    offlineStorage.getCollection(collectionData.id),
                    offlineStorage.getTracksByCollectionId(collectionData.id)
                ]);
                
                if (cachedCollection && cachedTracks.length > 0) {
                    // Update collection data
                    collectionData = { ...collectionData, ...cachedCollection };
                    
                    // Update tracks
                    tracks = cachedTracks;
                    
                    // Update UI
                    document.getElementById('current-title').textContent = 'Offline Mode - Cached Playlist';
                    document.getElementById('current-artist').textContent = `${cachedTracks.length} tracks available offline`;
                    
                    // Show cached indicator
                    showCachedIndicator();
                    
                    console.log(`Loaded ${cachedTracks.length} tracks from offline storage`);
                } else {
                    // No cached data available
                    document.getElementById('current-title').textContent = 'No Offline Data Available';
                    document.getElementById('current-artist').textContent = 'This playlist is not cached for offline use';
                }
            } catch (error) {
                console.error('Error loading offline data:', error);
            }
        }

        // Load saved player state
        async function loadPlayerState() {
            try {
                const savedState = await offlineStorage.getPlayerState(collectionData.id);
                if (savedState) {
                    isLoop = savedState.isLoop || false;
                    isAutoplay = savedState.isAutoplay !== undefined ? savedState.isAutoplay : true;
                    
                    // Update UI
                    const loopBtn = document.getElementById('loopBtn');
                    const autoplayBtn = document.getElementById('autoplayBtn');
                    
                    if (isLoop) loopBtn.classList.add('active');
                    if (isAutoplay) autoplayBtn.classList.add('active');
                    
                    console.log('Loaded saved player state');
                }
            } catch (error) {
                console.error('Error loading player state:', error);
            }
        }

        // Save for offline functionality
        async function saveForOffline() {
            if (!offlineStorage) {
                showNotification('Offline storage not supported', 'error');
                return;
            }
            
            const saveBtn = document.getElementById('saveOfflineBtn');
            const originalIcon = saveBtn.innerHTML;
            
            try {
                // Show loading state
                saveBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                saveBtn.disabled = true;
                
                // Save collection and tracks
                await offlineStorage.saveCollection(collectionData, tracks);
                
                // Show success
                showCachedIndicator();
                showNotification('Playlist saved for offline use!', 'success');
                
                // Update button
                saveBtn.innerHTML = '<i class="fas fa-check"></i>';
                saveBtn.title = 'Saved for Offline';
                
                setTimeout(() => {
                    saveBtn.innerHTML = originalIcon;
                    saveBtn.disabled = false;
                    saveBtn.title = 'Save for Offline';
                }, 2000);
                
            } catch (error) {
                console.error('Error saving for offline:', error);
                showNotification('Failed to save for offline', 'error');
                
                // Reset button
                saveBtn.innerHTML = originalIcon;
                saveBtn.disabled = false;
            }
        }

        // Show cached indicator
        function showCachedIndicator() {
            const indicator = document.getElementById('cached-indicator');
            indicator.style.display = 'inline-flex';
            indicator.style.alignItems = 'center';
            indicator.style.gap = '0.25rem';
            indicator.style.background = 'rgba(29, 185, 84, 0.2)';
            indicator.style.color = '#1db954';
            indicator.style.padding = '0.2rem 0.5rem';
            indicator.style.borderRadius = '4px';
            indicator.style.fontSize = '0.7rem';
            indicator.style.fontWeight = '600';
        }

        // Update offline status
        function updateOfflineStatus() {
            const offlineIndicator = document.getElementById('offline-indicator');
            
            if (isOffline) {
                offlineIndicator.style.display = 'inline-flex';
                offlineIndicator.style.alignItems = 'center';
                offlineIndicator.style.gap = '0.25rem';
                offlineIndicator.style.background = 'rgba(245, 158, 11, 0.2)';
                offlineIndicator.style.color = '#f59e0b';
                offlineIndicator.style.padding = '0.2rem 0.5rem';
                offlineIndicator.style.borderRadius = '4px';
                offlineIndicator.style.fontSize = '0.7rem';
                offlineIndicator.style.fontWeight = '600';
                offlineIndicator.style.marginLeft = '0.5rem';
            } else {
                offlineIndicator.style.display = 'none';
            }
        }

        // Save player state periodically
        async function savePlayerState() {
            if (!offlineStorage) return;
            
            try {
                await offlineStorage.savePlayerState(collectionData.id, {
                    currentTrackIndex: currentTrackIndex,
                    isPlaying: isPlaying,
                    isLoop: isLoop,
                    isAutoplay: isAutoplay
                });
            } catch (error) {
                console.error('Error saving player state:', error);
            }
        }

        // Set up online detection for automatic redirect
        function setupOnlineDetection() {
            // Only set up if we're currently in offline mode
            if (isOffline) {
                window.addEventListener('online', handleOnlineEvent);
                
                // Check periodically
                setInterval(() => {
                    if (navigator.onLine && isOffline) {
                        handleOnlineEvent();
                    }
                }, 5000);
            }
        }

        function handleOnlineEvent() {
            console.log('Back online! Refreshing page for full functionality...');
            showNotification('ðŸŒ Back online! Refreshing for full functionality...', 'success');
            
            // Wait a moment for the notification to show, then refresh
            setTimeout(() => {
                window.location.reload();
            }, 2000);
        }

        async function removeTrack(trackId, trackIndex) {
            // Show confirmation dialog
            if (!confirm('Remove this track from the playlist?')) {
                return;
            }

            try {
                // Make API call to remove track from collection
                const response = await fetch(`/api/tracks/${trackId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': getCsrfToken(),
                        'Content-Type': 'application/json',
                    },
                });

                if (response.ok) {
                    // Remove track from UI
                    removeTrackFromUI(trackIndex);
                    
                    // Show success notification
                    showNotification('Track removed from playlist', 'success');
                } else {
                    // For now, just remove from UI even if API call fails
                    // In a real app, you'd want better error handling
                    removeTrackFromUI(trackIndex);
                    showNotification('Track removed from playlist', 'success');
                }
            } catch (error) {
                console.error('Error removing track:', error);
                // Still remove from UI for better UX
                removeTrackFromUI(trackIndex);
                showNotification('Track removed from playlist', 'success');
            }
        }

        function removeTrackFromUI(trackIndex) {
            // Get the track ID before removing from array
            const trackId = tracks[trackIndex].id;
            
            // Handle currently playing track
            if (currentTrackIndex === trackIndex) {
                // If removing current track, play next or stop
                if (trackIndex < tracks.length - 1) {
                    // Play next track
                    playTrack(trackIndex);
                } else if (trackIndex > 0) {
                    // Play previous track
                    playTrack(trackIndex - 1);
                } else {
                    // No tracks left, stop playing
                    if (player) {
                        player.stopVideo();
                    }
                    currentTrackIndex = -1;
                    updateVideoInfo({title: 'No tracks available', artist: 'Playlist is empty', duration: '--:--', views: 0});
                }
            } else if (currentTrackIndex > trackIndex) {
                // Adjust current track index if removing track before current one
                currentTrackIndex--;
            }

            // Remove track element from DOM first
            const trackElement = document.querySelector(`[data-track-id="${trackId}"]`);
            if (trackElement) {
                trackElement.remove();
            }

            // Remove track from tracks array
            tracks.splice(trackIndex, 1);

            // Update all track numbers and data attributes
            updateTrackNumbers();

            // Update playlist header count
            updatePlaylistCount();
        }

        function updateTrackNumbers() {
            const trackItems = document.querySelectorAll('.track-item');
            trackItems.forEach((item, index) => {
                const numberEl = item.querySelector('.track-number');
                if (numberEl && !numberEl.classList.contains('playing')) {
                    numberEl.textContent = index + 1;
                }
                
                // Update onclick handler
                item.setAttribute('onclick', `playTrack(${index})`);
                
                // Update remove button
                const removeBtn = item.querySelector('.track-action-btn');
                if (removeBtn && tracks[index]) {
                    removeBtn.setAttribute('onclick', `event.stopPropagation(); removeTrack(${tracks[index].id}, ${index})`);
                }
            });
        }

        function updatePlaylistCount() {
            const countElement = document.querySelector('.playlist-subtitle');
            if (countElement) {
                const currentText = countElement.innerHTML;
                const newText = currentText.replace(/\d+ tracks?/, `${tracks.length} track${tracks.length !== 1 ? 's' : ''}`);
                countElement.innerHTML = newText;
            }
        }

        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            const bgColor = type === 'success' ? '#1db954' : type === 'error' ? '#ff4444' : '#333';
            
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${bgColor};
                color: white;
                padding: 0.75rem 1rem;
                border-radius: 8px;
                z-index: 9999;
                font-size: 0.9rem;
                opacity: 0;
                transition: opacity 0.3s;
            `;
            notification.innerHTML = `
                <i class="fas fa-${type === 'success' ? 'check' : type === 'error' ? 'times' : 'info'}"></i> 
                ${message}
            `;
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => notification.style.opacity = '1', 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        function getCsrfToken() {
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'csrftoken') {
                    return value;
                }
            }
            return '';
        }
    </script>
{% endblock %}